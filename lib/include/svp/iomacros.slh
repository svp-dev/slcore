sl_begin_header([[SLC_SVP_IOMACROS_SLH]])m4_dnl -*- m4 -*-
//
// iomacros.slh: this file is part of the slc project.
//
// Copyright (C) 2009 The SL project.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 3
// of the License, or (at your option) any later version.
//
// The complete GNU General Public Licence Notice can be found as the
// `COPYING' file in the root directory.
//
// $Id$
//

m4_include(svp/io.slh)

/*
 * The following macro definitions encapsulate the corresponding
 * thread functions from svp/io.slh as macros that are suitable
 * for use as statements in programs.
 */

m4_define([[putc]],
[[
sl_proccall(svp_io_putc, sl_glarg(char, c, ([[$1]])))
]])

m4_define([[puts]],
[[
sl_proccall(svp_io_puts, sl_glarg(const char*, s, ([[$1]])))
]])

m4_define([[write]],
[[
sl_proccall(svp_io_write, sl_glarg(void*, s, ([[$1]])), sl_glarg(unsigned, i, ([[$2]])))
]])

m4_define([[putf]],
[[
sl_proccall(svp_io_putf,
              sl_glfarg(double, d, ([[$1]])),
              sl_glarg(unsigned, gprec, ([[$2]])),
              sl_glarg(unsigned, gbase, 10))
]])

m4_define([[putn]],
[[
sl_proccall(svp_io_putn,
	    sl_glarg(long long, n, ([[$1]])),
            sl_glarg(unsigned, gbase, 10))
]])

m4_define([[putu]],
[[
sl_proccall(svp_io_putun,
            sl_glarg(unsigned long long, n, ([[$1]])),
            sl_glarg(unsigned, gbase, 10))
]])

m4_define([[printf]],
[[do {
  static const uint8_t __pf_sz[m4_count(m4_shift($@))] = {
    m4_if([[$2]],[[]],,[[
      m4_foreach([[printf_arg]],m4_dquote(m4_shift($@)),[[sizeof(printf_arg),]])
    ]])
  };
  volatile struct {
    m4_if([[$2]],[[]],,[[
      m4_pushdef([[printf_argcount]],0)
      m4_foreach([[printf_arg]],m4_dquote(m4_shift($@)),[[
        union { __typeof__(printf_arg) __arg; svp_arg_slot __slot; }
          __a[[]]printf_argcount;
        m4_step([[printf_argcount]])
      ]])
      m4_popdef([[printf_argcount]])
    ]])
  } __pf_args;
  m4_if([[$2]],[[]],,[[
   m4_pushdef([[printf_argcount]],0)
   m4_foreach([[printf_arg]],m4_dquote(m4_shift($@)),[[
   __pf_args.__a[[]]printf_argcount[[]].__arg = (printf_arg);
   m4_step([[printf_argcount]])
   ]])
   m4_popdef([[printf_argcount]])
  ]])
  sl_proccall(svp_io_printf,
              sl_glarg(const char*, gfmt, ([[$1]])),
	      sl_glarg(const uint8_t*, gsz, (__pf_sz)),
              sl_glarg(svp_arg_slot*, gdata, (svp_arg_slot*)(void*)&__pf_args));
} while(0)]])


sl_end_header([[SLC_SVP_IOMACROS_SLH]])
