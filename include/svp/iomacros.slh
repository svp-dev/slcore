m4_ifndef([[SV_IOMACROS_SLH]], [[m4_define([[SVP_IOMACROS_SLH]],1)

m4_include(svp/io.slh)

/*
 * The following macro definitions encapsulate the corresponding
 * thread functions from svp/io.slh as macros that are suitable
 * for use as statements in programs.
 */

m4_define([[putc]],
[[do { 
  sl_proccall(svp_io_putc, sl_glarg(char, c, ([[$1]]))); 
} while(0)]])

m4_define([[puts]],
[[do { 
  sl_proccall(svp_io_puts, sl_glarg(const char*, s, ([[$1]]))); 
} while(0)]])

m4_define([[putf]],
[[do {
  sl_proccall(svp_io_putf, 
              sl_glfarg(double, d, ([[$1]])),
              sl_glarg(unsigned, gprec, ([[$2]])), 
              sl_glarg(unsigned, gbase, 10));
} while(0)]])

m4_define([[putn]], 
[[do {
sl_proccall(svp_io_putn, 
	    sl_glarg(long long, n, ([[$1]])),
            sl_glarg(unsigned, gbase, 10));
} while(0)]])

m4_define([[putu]], 
[[do {
sl_proccall(svp_io_putun, 
            sl_glarg(unsigned long long, n, ([[$1]])), 
            sl_glarg(unsigned, gbase, 10));
} while(0)]])

m4_define([[printf]], 
[[do {
  struct {
    m4_pushdef([[printf_argcount]],0)
    m4_foreach([[printf_arg]],m4_dquote(m4_shift($@)),[[
      union { __typeof__(printf_arg) __arg; svp_arg_slot __slot; } 
        __a[[]]printf_argcount;
      m4_step([[printf_argcount]])
    ]])
    m4_popdef([[printf_argcount]])
  } __pf_args = {
    m4_foreach([[printf_arg]],m4_dquote(m4_shift($@)),[[{ (printf_arg) },]])
  };
  sl_proccall(svp_io_printf,
              sl_glarg(const char*, gfmt, ([[$1]])),
              sl_glarg(svp_arg_slot*, gdata, (svp_arg_slot*)(void*)&__pf_args));
} while(0)]])


]])

