#! @BASH@
#
# slr: This file is part of the SL toolchain.
#
copyright="Copyright (C) 2009 The SL project."
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# The complete GNU General Public Licence Notice can be found as the
# `COPYING' file in the root directory.
#
# $Id$
#
set -e
python=${PYTHON:-@python@}
slc_helper=${SLC:-@slc_helper@}
sag_helper=${SAG:-@sag_helper@}
slc_libdir=${SLC_LIBDIR:-@slc_libdir@}
slc_datadir=${SLC_DATADIR:-@slc_datadir@}
TMPDIR=${TMPDIR:-/tmp}

version=@slc_version@
slrev=@slc_revision@
bugreports=@bugreports@

do_usage() {
  cat <<EOF
SL Runner.

The \`slr' utility provides a single interface to run a SVP program
compiled with \`slc'. \`slr' analyses the executable file to determine
how to run the program, and invokes the simulator if needed.

This uses the SL input mechanism described in CSA note [sl3].

Usage: $0 [OPTION] PROGRAM [ARGS]...

Program input options:
  -l                   List variables required as input by the program.

  -dVAR                Define the program input VAR as an empty array.

  -dVAR=..., VAR=...   Define the program input VAR as specified (see 
                       CSA note [sl3] for details).

  -w FILE              Save the binary input data generated by the -d flags
                       to the specified FILE.

  -r FILE              Load the binary input data saved previously with -w from
                       FILE. This overrides any -d option.

Execution selection:
  -n N                 Try to run with only N SVP cores.

  -c                   Show configuration string embedded in program, if any.

  -x RUNNER            Use the specified RUNNER (use when autodetect fails).

  -Ws,arg              Pass "arg" as extra command line parameter to the 
                       simulator, when the simulator is used.

Debugging options:
  -t                   Trace: print commands before running them.

  -g                   Debug: try to run debugger around program. Implies -x.

Other options:
  -h, --help           Print this help, then exit.

  -v, --version        Print version number, then exit.

Environment variables:
  VERBOSE              If set and not empty, implies option -t.

  DEBUG                If set and not empty, implies option -g.

  DEBUGGER             Command prefix to use as debugger. 
                       Default is \`gdb --args'.

  SIMARGS              Combines with the occurrences of option -Ws on
                       the command line when running the simulator.

  TMPDIR             If set and not empty, overrides /tmp as the
                     base directory for temporary files.

Examples:

  \$ slr -c a.out 

  Shows runner string stored in \`a.out'.

  \$ slr fibo.x -dN=15

  Runs fibo.x, possibly using the MT simulator, and set program input
  variable N to an array of 1 element with value "15".

  \$ slr fibo.x N=10 -n 7

  Runs fibo.x, possibly using the MT simulator, and set program input
  variable N to an array of 1 element with value "10". Try to run
  with 7 SVP cores.

Report bugs and patches to $bugreports.
EOF
  exit 0
}

do_version() {
  rev='$Rev$'
  rev=$(echo "$rev"|cut -d' ' -f2)
  cat <<EOF
slr $version (rev $slrev/$rev)

$copyright
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

Written by Raphael 'kena' Poss.
EOF
  exit 0
}

die() {
  printf '%s: %s\n' "$0" "$2" >&2
  exit $1
}

# Command line analysis
prev_arg=
show_embedded=
vars=
program=
query=
rdatafile=
wdatafile=
NCORES=${NCORES:-}
SIMARGS=${SIMARGS:-}
VERBOSE=${VERBOSE:-}
DEBUG=${DEBUG:-}
for arg in "$@"; do
  # if the previous option needs an argument, assign it
  if test -n "$prev_arg"; then
     eval "$prev_arg=\$arg"
     prev_arg=
     shift
     continue
  fi
  case $arg in
      -x)	prev_arg=runner; shift;;
      -c)	show_embedded=1; shift;;
      -t)       VERBOSE=1; shift;;
      -g)	VERBOSE=1; DEBUG=1; shift;;
      -v|--version)	do_version;;
      -h|--help)	do_usage;;
      -l)  query=1; shift;;
      -n)  prev_arg=NCORES; shift;;
      -Ws*)   lowarg=$(echo "$arg"|cut -d',' -f2-|tr ',' ' ')
	  SIMARGS="$SIMARGS $lowarg"
	  shift;;
      -d*=*) var=$(printf "%s" "$arg"|cut -c3-); vars="$vars $var"; shift;;
      -d*) var=$(printf "%s" "$arg"|cut -c3-); vars="$vars $var="; shift;;
      -r)  prev_arg=rdatafile; shift;;
      -w)  prev_arg=wdatafile; shift;;
      --)  break;;
      -*)  die 1 "unrecognized command-line argument: $arg (try -h)";;
      *=*) vars="$vars $arg"; shift ;;
      *)   if test -z "$program"; then program=$arg; shift
           else die 1 "unrecognized command-line argument: $arg (try -h)"
	   fi ;;
  esac
done


# does the program exist?
if ! test -f "$program"; then
  die 127 "no such file or directory: $program"
fi

# is it executable?
if ! test -x "$program"; then
  die 126 "permission denied: $program"
fi

if test -n "$show_embedded" -o -z "$runner"; then
  tag=$(strings "$program"|grep '^slr_runner:.*:'|tail -n1|cut -d: -f2)
  if test "x$tag" = "x"; then
    if test -n "$show_embedded"; then
       echo "(none found)"
       exit 0    
    fi
  else
    if test -n "$show_embedded"; then
       echo "$tag"
       exit 0    
    fi
  fi
fi

datatag=$(strings "$program"|grep '^slr_datatag:.*:'|tail -n1|cut -d: -f2)
if test "x$datatag" = "x"; then
    die 1 "can't determine cce tag to recompile"
fi


if test -z "$runner"; then
  # Not specified, use tag if found
  if test -n "$tag"; then
     runner=$tag
  else
     die 1 "can't determine runner (try -r)"
  fi
fi

# check it
runner_script=
saveIFS=$IFS
IFS=:
for l in $slc_libdir; do
  if test -r "$l/r-$runner/run.sh"; then
     runner_script=$l/r-$runner/run.sh
     break
  fi
done
if test -z "$runner_script"; then
    die 1 "$runner: cannot find runner script"
fi
IFS=$saveIFS

cleanfiles=
docleanup() {
    for f in $cleanfiles; do
	if test -z "$KEEP"; then
	    rm -rf "$f" >/dev/null 2>&1
	else
	    echo "$0: $f: left over temporary" >&2
	fi
    done
}

trapcleanup() {
    local sig
    sig=$1
    docleanup
    trap - INT PIPE TERM QUIT ALRM
    kill -$sig $$
}
errcleanup() {
    docleanup
    trap - ERR
    exit 1
}

if test -n "$rdatafile"; then
  if ! test -r "$rdatafile"; then die "$rdatafile: cannot read file"; fi
  if test -n "$vars"; then 
    echo "$0: warning: '-r $rdatafile' overrides '$vars'" >&2
  fi
  datafile=$rdatafile
  dodata=
else
  dodata=1
fi

trap 'trapcleanup INT' INT
trap 'trapcleanup PIPE' PIPE
trap 'trapcleanup TERM' TERM
trap 'trapcleanup QUIT' QUIT
trap 'trapcleanup ALRM' ALRM
trap 'errcleanup' ERR

if test -n "$dodata"; then
    # build temporary directory
    baseout=$(basename "$program")
    tmpdir=$(mktemp -d $TMPDIR/"$baseout".XXXXXXXX)
    cleanfiles=$tmpdir

    if test -n "$wdatafile"; then
	datafile=$wdatafile
    else    
	datafile="$tmpdir"/data
    fi
    
    # check program parameters
    strings "$program" | (grep '^slr_arg:'||true) >"$tmpdir"/args.spec
    if test -n "$query"; then
	$python "$sag_helper" list <"$tmpdir"/args.spec
	exit 0
    fi
      
    if test -s "$tmpdir"/args.spec; then
	if test -n "$VERBOSE"; then
	    echo "$0: running: $python $sag_helper $vars <$tmpdir/args.spec >$tmpdir/data.c" >&2
	fi
	$python "$sag_helper" $vars <"$tmpdir"/args.spec >"$tmpdir"/data.c
	
	found=
	saveIFS=$IFS
	IFS=:
	for d in $slc_datadir; do
	    if test -r "$d/arggen.sl"; then
		found=$d/arggen.sl
		break
	    fi
	done
	IFS=$saveIFS
	if test -z "$found"; then
	    die 1 "arggen.sl not found in $slc_datadir"
	fi
	mkdir "$tmpdir"/slc-rec
	if test -n "$VERBOSE"; then
	    echo "$0: running: TMPDIR=$tmpdir/slc-rec @BASH@ $slc_helper -b $datatag -o $tmpdir/gen.x -I$tmpdir $found" >&2
	fi
	TMPDIR="$tmpdir"/slc-rec @BASH@ "$slc_helper" -b "$datatag" -o "$tmpdir"/gen.x -I"$tmpdir" "$found"
	mkdir "$tmpdir"/slr-rec
	if test -n "$VERBOSE"; then
	    echo "$0: running: TMPDIR=$tmpdir/slr-rec @BASH@ $0 $tmpdir/gen.x >$datafile" >&2
	fi
	TMPDIR="$tmpdir"/slr-rec @BASH@ "$0" "$tmpdir"/gen.x -Ws,-q >"$datafile"
    else
        true >"$datafile"
    fi
fi
#set +e
export SIMARGS VERBOSE DEBUG NCORES
if test -n "$VERBOSE"; then
    echo "$0: running: @BASH@ $runner_script $program $datafile" >&2
fi
@BASH@ "$runner_script" "$program" "$datafile"
#set -e
docleanup
trap - ERR
#trap - ERR INT PIPE TERM QUIT ALRM
#if test $x -gt 128; then
#    kill -$(expr $x - 128) $$
#fi
#exit $x
    
    