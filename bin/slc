#! /bin/bash
# $Id$
#
copyright="Copyright (C) 2009 the CSA group - The SL project."
#
# This program is free software: you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by   
# the Free Software Foundation; either version 2, or (at your option)    
# any later version.  
#   
# This program is distributed in the hope that it will be useful,   
# but WITHOUT ANY WARRANTY; without even the implied warranty of    
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     
# GNU General Public License for more details.    
#   
# You should have received a copy of the GNU General Public License 
# along with this program; if not, write to the Free Software 
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA     
# 02110-1301, USA.    
set -e
root=$(cd $(dirname "$0") && pwd)
basename=$(basename "$0")
incdir=$(cd "$root/../include" && pwd)
libdir=$(cd "$root/../lib" && pwd)

# Interface version number
version=2

# Load defaults
slc_mode=ld
impl=seqc
m4trace=
synclines=yes
combine=
verbose=

check=
prev_arg=

inputs=
tempfiles=
tempdirs=
inflight=
outfile=
tmpdir=

keep=$KEEP

extra_inc=
extra_ppflags=
extra_asflags=
extra_cflags=
extra_ldflags=

M4=${M4:-m4}

# Setting up some cleanup mechanism
cleanup() {
  for f in $inflight $tempfiles $tempdirs; do
    if test -z "$keep"; then 
      test -n "$verbose" && echo "$0: $f: deleting temporary" >&2
      if test -d "$f"; then 
	  if ! rmdir "$f" ; then
	      echo "$0: $f: warning: could not delete directory" >&2
	  fi
      else 
	  rm -f "$f"
      fi
    else
      test -e "$f" && echo "$0: $f: left over temporary" >&2
    fi
  done
  inflight=
  tempfiles=
  tempdirs=
}
trap cleanup 0 ERR INT TERM QUIT

die() {
    echo "$0:" "$@" >&2
    exit 1
}

# Command line analysis
for arg in "$@"; do
  # if the previous option needs an argument, assign it
  if test -n "$prev_arg"; then
     eval "$prev_arg=\$arg"
     prev_arg=
     continue
  fi

  case $arg in
      --version) slc_mode=display_version ;;
      -h|--help) slc_mode=display_help ;;

      -check)	check=yes;;

      -EE)	slc_mode=trans;;
      -E)	slc_mode=pp;;
      -S0)      slc_mode=cc;;
      -S)	slc_mode=filt;;
      -c)       slc_mode=as;;

      -b)	prev_arg=impl;;

      -t)       prev_arg=tmpdir;;

      -P)	synclines= ;;
      -o)	prev_arg=outfile;;
      -ftrace-m4=*) m4trace=$(echo "$arg"|cut -d= -f2-);;
      -save-temps) keep=yes ;;
      -v)       verbose=yes ;;
      -combine=*) combine=$(echo "$arg"|cut -d= -f2);;
      -combine)   combine=C ;;

      -L*|-Wl,*)     extra_ldflags="$extra_ldflags $arg" ;;
      -l*)           in_ld_spec="$in_ld_spec $arg" ;;
      -D*|-U*)       extra_ppflags="$extra_ppflags $arg" ;;
      -I*)           extra_inc="$extra_inc $arg" ;;
      -Wa,*)         extra_asflags="$extra_asflags $arg" ;;

      -x)       die "-x not supported yet" ;;

      -mutc*)   die "-mutc is deprecated, used -b instead" ;;

      -*)	extra_cflags="$extra_cflags $arg";;

# Legacy file types
      *.i|*.ii) in_cc_spec="$in_cc_spec $arg";;
      *.C|*.cxx|*.c++|*.cc|*.cp|*.cpp) in_pp_spec="$in_pp_spec $arg";;
      *.S|*.c) in_pp_spec="$in_pp_spec $arg";;
      *.s)     in_as_spec="$in_as_spec $arg";;
# SLC file types
      *.iu)  in_cc_spec="$in_cc_spec $arg";;
      *.utc) in_pp_spec="$in_pp_spec $arg";;
      *.sl)  in_slt_spec="$in_slt_spec $arg";;
      *.s0)  in_filt_spec="$in_filt_spec $arg";;
# Default behavior: feed input to linker
      *) in_ld_spec="$in_ld_spec $arg";;
  esac
done

# Special actions that do not require processing
if test "x$slc_mode" = xdisplay_version; then
   rev='$Rev$'
   rev=$(echo "$rev"|cut -d' ' -f2)
   cat <<EOF
$basename $version.$rev

$copyright
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

Written by Raphael 'kena' Poss.
EOF
   exit 0
elif test "x$slc_mode" = xdisplay_help; then
   cat <<EOF
SVP Language Compiler.

\`$basename' is a generic compiler driver for SVP programs. It provides a
unified command line interface for compiling SVP code. The actual
tools used for compilations are selected automatically depending on
the selected SVP implementation, using the separate utility \`cce'.

The following transforms are applied depending on the type of the
input (determined by the file name suffix):

- translate: the SVP language is translated to an actual SVP
dialect. This transform uses the M4 preprocessor.

- preprocess: the source code is filtered by the C/C++ preprocessor.

- compile: the source code is transformed to raw assembly; the
compiler used depends on the SVP dialect and the target
architecture.

- filter: (for the Microgrids implementations) the raw assembly is
further distilled.

- assemble; the assembler used depends on the target architecture.

- link; the linker used depends on the target architecture.

Except for the two additional transforms (translate and filter),
\`$basename' mimics the driver of the GNU Compiler Collection (\`gcc'). For
general information about default behavior, additional flags and
processing order, see gcc(1).

Usage: $0 [ARG]...

Options:

  -check             Check the environment; do not process anything. In
                     this mode $basename checks that the required tools
                     are available.

  -EE                Stop after the translation stage; do not preprocess.
                     The output is in the form of translated source code,
                     which is sent to the standard output.

  -E                 Stop after the preprocessing stage; do not compile.
                     The output is in the form of preprocessed source code,
                     which is sent to the standard output.

  -S0                Stop after the first stage of compilation proper; do not
                     perform post-compilation filtering on assembly. 
                     The output is in the form of an unprocessed assembler code
                     file for each non-assembler input file specified.

  -S                 Stop after the second stage of compilation proper;
                     do not assemble. The output is in the form of an assembler
                     code file for each non-assembler input file specified.

  -c                 Compile or assemble the source files, but do not link.
                     The linking stage is not done. The output is in the
                     form of an object file for each source file.

SVP implementation selection:
  -b spec            Generate code for the SVP implementation specified by
                     "spec". "spec" is passed through \`cce' for validation
                     and alias expansion. See \`cce --help' for details. The
                     default implementation is "seqc".

Input file types:
  file.sl            SVP code which must be translated.

  file.utc           muTC source code which must be preprocessed.

  file.iu            muTC source code which should not be preprocessed.

  file.s0            Assembler code which should be further distilled.

The regular GCC file types are also recognized and are transformed
accordingly.

General options:
  -Idir              Add the directory "dir" to the list of directories
                     to be searched for header files. This applies
                     both to the initial translation by M4 and to the
                     underlying compiler.

  -P                 Inhibit generation of linemarkers in the output
                     from both the initial translation by M4 and the C
                     preprocessor.

  -combine=[PHASES]  Group input files into a single output for each of
                     the specified PHASES.

  -combine           Synonymous with -combine=C (behavior similar to \`gcc').

  -o file            Place output in "file". This implies -combine for the
                     phase where \`$basename' is configured to stop.


Compiler debugging options:
  -v                 Print (on standard error output) the commands executed
                     to run the stages of compilation. Also print the
                     settings and version number of the tools involved.

  -ftrace-m4=file    Dump the m4 macro expansion trace to file "file".

  -save-temps        Keep intermediate files. If this option is not set,
                     intermediate files generated during compilation are
                     deleted before the program terminates.

Other options:
  -h, --help         Print this help; do not process anything.

  --version          Print $basename's version number; do not process 
                     anything.

All other options are passed transparently to the appropriate
tools; in particular, the following options may prove useful:

  -Dmacro, -Umacro   Set/unset C/C++ preprocessor macros.

  -Wa,option         Pass "option" as an option to the assembler.

  -Wl,option         Pass "option" as an option to the linker.

  -Ldir              Search "dir" for libraries when linking.

  -llibrary          Link with the library named "library".

Environment variables:
  M4                 M4 preprocessor to use. Default is "m4".

  KEEP               If set and not empty, implies option -save-temps.

Diagnostics:
  0                  No error occured.

  1                  Invalid parameters passed to \`$basename' or 
                     invalid configuration.

  2                  Translation failed.

  3                  Preprocessing failed.

  4                  Compilation failed.

  5                  Post-compilation filtering failed.

  6                  Assembly failed.

  7                  Linking failed.

  127                A tool was not found.

  126                A program could not be executed.

Examples:

  $basename test.sl

  $basename -o test test1.sl test2.sl

  $basename -EE test.sl

  $basename -S -o test.s test.sl

  $basename -o test test.sl ccode.c

Report bugs and suggestions to the CSA issue tracker.
EOF
   exit 0
fi

# Here check the configuration
eval $("$root"/cce -s "$impl")

# If we were requested to test the configuration, do it now
if test -n "$check"; then
    if ! test -d $slc_trans; then
	echo "$slc_trans: does not exist or is not a directory" >&2
	exit 1
    else echo "Found translator: $slc_trans"; fi
    if ! $slc_compiler --version >/dev/null 2>&1; then
	echo "$slc_compiler: cannot run" >&2
	exit 1
    else echo "Found compiler: $slc_compiler"; fi
    if ! $slc_aslink --version >/dev/null 2>&1; then
	echo "$slc_aslink: cannot run" >&2
	exit 1
    else echo "Found assembler/linker compiler: $slc_aslink"; fi
    
    echo "Good." >&2
fi

########################
# Set KEEP if specified
########################
if test -n "$keep"; then
   export KEEP=1
fi

###################################
# Command line additions
###################################
# Include directories
includes="-I$slc_trans -I$incdir"

slc_ppflags="$slc_ppflags $includes $extra_inc"
slc_tflags="$slc_tflags $includes $extra_inc"
case $slc_complang in
    cpp) 
	slc_cflags="$slc_cflags $CXXFLAGS" 
	slc_ppflags="$slc_ppflags $CXXPPFLAGS"
	;;
    c)  
	slc_cflags="$slc_cflags $CFLAGS"
	slc_ppflags="$slc_ppflags $CPPFLAGS"
	;;
    utc) 
	slc_cflags="$slc_cflags $UTCFLAGS"
	slc_ppflags="$slc_ppflags $UTCPPFLAGS"
	;;
esac
slc_ppflags="$slc_ppflags -DSVP_ARCH=$slc_arch -DSVP_DIALECT=$slc_dialect -DSVP_OS=$slc_os $extra_ppflags"
slc_cflags="$slc_cflags $extra_cflags"
slc_asflags="$slc_asflags $slc_cflags $ASFLAGS $extra_asflags"
slc_ldflags="$slc_ldflags $slc_cflags $LDFLAGS $extra_ldflags"


###################################
# Settings special for M4
###################################

# m4 -P: prefix M4 builtins with m4_
# -E: stop after errors
m4flags="-E -P"

if test -n "$synclines"; then
  m4flags="$m4flags -s"
else
  # cpp -P: do not generate synclines
  slc_ppflags="$slc_ppflags -P"
fi

if test -n "$m4trace"; then
  m4flags="$m4flags -dV -o $m4trace"
fi

m4flags="$m4flags $slc_tflags"

###################################
# Construction of compilation chain
###################################

# Select file extension for intermediate source files
case $slc_complang in
    c)
	cc_ext=i
	pp_ext=c
	;;
    cpp)
	cc_ext=ii
	pp_ext=cc
	;;
    utc)
	cc_ext=iu
	pp_ext=utc
	;;
    *)
	die "unrecognized mode $mode" ;;
esac

# Create temporary directory if necessary
if test -n "$tmpdir"; then
    if ! test -d "$tmpdir" -a -w "$tmpdir"; then
	die "$tmpdir: cannot write to directory"
    fi
else
    tmpdir=$(mktemp -d -t slc)
    tempdirs=$tmpdir
fi

# Decide what phases to do and where to stop
defout=-
case $slc_mode in 
    trans) finalstage=T;;
    pp) finalstage=P;;
    cc) finalstage=C;;
    filt) finalstage=F;;
    as) finalstage=A;;
    ld) finalstage=L; defout=a.out;;
esac
combine="$finalstage$combine"
finalname=${outfile:-$defout}

prepare_chain() {
    local inputs addext stage indvar specfiles phrase
    local f first f final target some
    
    inputs=$1
    addext=$2
    stage=$3
    indvar=$4
    specfiles=$5
    phrase=$6
    
    target=
    if test "x$skip" = "x"; then
	if ! expr "$combine" : ".*$stage" >/dev/null; then
	    for f in $inputs; do
		fn=${f##*/}; fn=${fn%*.*}

		case $f in
		    *.S) 
			target=$tmpdir/$fn.s
			in_as_ind="$in_as_ind $target"
			;;
		    *)
			target=$tmpdir/$fn.$addext
			eval "$indvar=\$$indvar' $target'"
		esac
		transforms="R:$target $transforms $stage:$target:$f"
	    done
	else
	    transform=
	    first=
	    for f in $inputs; do
		if test -z "$first"; then first=$f; fi
		transform="$transform:$f"
	    done
	    if test -n "$transform"; then 
		fn=${first##*/}; fn=${fn%*.*}
#		fn=$(basename "$first"|sed -e 's/^\(.*\)\.[^.]*$/\1/g')
		targetbase=$fn.$addext
		if test "x$finalstage" = "x$stage"; then
		    if test "x$finalname" = "x-"; then
			target=$targetbase
		    else
			target=$finalname
		    fi
		else
		    target=$tmpdir/$targetbase
		    transforms="R:$target $transforms"
		fi
		transforms="$transforms $stage:$target$transform"
	    fi
	    if test "x$finalstage" = "x$stage"; then skip=1; fi
	    eval "$indvar=\$$indvar' $target'"
	fi
    else
	for f in $specfiles; do
	    echo "$0: $f: $phrase input file unused because $phrase not run" >&2
	done
    fi
}


# Item lists:
# *_spec: specified on command lne
# *_ind: derivatives

skip=
prepare_chain "$in_slt_spec" $pp_ext T in_pp_ind "$in_slt_spec" "translation"
prepare_chain "$in_pp_ind $in_pp_spec" $cc_ext P in_cc_ind "$in_pp_spec" "preprocessor"
prepare_chain "$in_cc_ind $in_cc_spec" s0 C in_filt_ind "$in_cc_spec" "compiler"
prepare_chain "$in_filt_ind $in_filt_spec" s F in_as_ind "$in_filt_spec" "post-filter"
prepare_chain "$in_as_ind $in_as_spec" o A in_ld_ind "$in_as_spec" "assembler"
prepare_chain "$in_ld_ind $in_ld_spec" x L unused "$in_ld_spec" "linker"

##############################################
# Start processing

# Print configuration if requested
if test -n "$verbose"; then
  echo "---- $basename: options and settings ----" >&2
  for i in root keep impl \
           M4 m4flags \
           combine outfile tmpdir; do
    eval "echo '  ' $i '->' \$$i" >&2
  done
  set | grep '^slc_'
  echo "---- $basename: build plan -----" >&2
  for i in $transforms; do echo $i >&2; done
  echo "---- $basename: processing... ----" >&2
fi

for t in $transforms; do
  IFS=':' read action target indeps <<EOF 
$t
EOF
  indeps=${indeps/:/ }
  deps=
  for d in $indeps; do
      case $d in
	  *.iu) deps="$deps -x cpp-output $d -x none";;
	  *) deps="$deps $d" ;;
      esac
  done
  capturestdout=
  case $action in
      R) tempfiles="$tempfiles $target"; continue ;;
      T) 
	  res=2
	  cmd="$M4 $m4flags $incdir/proto.m4 $deps"
	  if ! test "$slc_mode" = "trans" -a -z "$outfile"; then capturestdout=1; fi
	  ;;
      P)
	  res=3
	  cmd="$slc_compiler -E $deps $slc_ppflags"
	  if ! test "$slc_mode" = "pp" -a -z "$outfile"; then capturestdout=1; fi
	  ;;
      C)
	  res=4
	  cmd="$slc_compiler -o $target -combine -S $deps $slc_cflags"
	  ;;
      F)
	  res=5
	  if test "x$slc_filter" = "xcp"; then
	      cmd="cat $deps"
	      capturestdout=1
	  else
	      cmd="$slc_filter $target $deps"
	  fi
	  ;;
      A)
	  res=6
	  cmd="$slc_aslink -c -o $target $deps $slc_asflags"
	  ;;
      L)
	  res=7
	  cmd="$slc_aslink -o $target $deps $slc_ldflags"
	  ;;
  esac

  inflight=$target
  export SLC_PHASE=$action
  if test -n "$capturestdout"; then
      if test -n "$verbose"; then echo "$action: $cmd >$target" >&2; fi
      set +e
      $cmd >"$target"
      cmdcode=$?
      set -e
  else
      if test -n "$verbose"; then echo "$action: $cmd" >&2; fi
      set +e
      $cmd
      cmdcode=$?
      set -e
  fi
  inflight=
  if test -n "$verbose"; then echo "=> $cmdcode" >&2; fi
  if test $cmdcode -gt 126; then
      if test -n "$verbose"; then echo "signal or command not found: exit $cmdcode" >&2; fi
      exit $cmdcode
  elif test $cmdcode -gt 0; then
      if test -n "$verbose"; then echo "$action failed: exit $res" >&2; fi
      exit $res
  fi
done

test -n "$verbose" && echo "---- $basename: done. ----" >&2
exit 0


