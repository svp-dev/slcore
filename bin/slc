#! /bin/bash
# $Id$
set -e
root=$(cd $(dirname "$0") && pwd)
basename=$(basename "$0")
incdir=$(cd "$root/../include" && pwd)
libdir=$(cd "$root/../lib" && pwd)

# Interface version number
version=2

# Load defaults
slc_mode=ld
impl=seqc
m4trace=
synclines=yes
combine=
verbose=

check=
prev_arg=

inputs=
tempfiles=
tempdirs=
inflight=
outfile=
tmpdir=

keep=$KEEP

extra_inc=
extra_ppflags=
extra_asflags=
extra_cflags=
extra_ldflags=

M4=${M4:-m4}

# Setting up some cleanup mechanism
cleanup() {
  for f in $inflight $tempfiles $tempdirs; do
    if test -z "$keep"; then 
      test -n "$verbose" && echo "$0: $f: deleting temporary" >&2
      if test -d "$f"; then 
	  if ! rmdir "$f" ; then
	      echo "$0: $f: warning: could not delete directory" >&2
	  fi
      else 
	  rm -f "$f"
      fi
    else
      test -e "$f" && echo "$0: $f: left over temporary" >&2
    fi
  done
  inflight=
  tempfiles=
  tempdirs=
}
trap cleanup 0 ERR INT TERM QUIT

die() {
    echo "$0:" "$@" >&2
    exit 1
}

# Command line analysis
for arg in "$@"; do
  # if the previous option needs an argument, assign it
  if test -n "$prev_arg"; then
     eval "$prev_arg=\$arg"
     prev_arg=
     continue
  fi

  case $arg in
      --version) slc_mode=display_version ;;
      -h|--help) slc_mode=display_help ;;

      -check)	check=yes;;

      -EE)	slc_mode=trans;;
      -E)	slc_mode=pp;;
      -S0)      slc_mode=cc;;
      -S)	slc_mode=filt;;
      -c)       slc_mode=as;;

      -b)	prev_arg=impl;;

      -t)       prev_arg=tmpdir;;

      -P)	synclines= ;;
      -o)	prev_arg=outfile;;
      -ftrace-m4=*) m4trace=$(echo "$arg"|cut -d= -f2-);;
      -save-temps) keep=yes ;;
      -v)       verbose=yes ;;
      -combine=*) combine=$(echo "$arg"|cut -d= -f2);;
      -combine)   combine=C ;;

# Legacy file types
      *.i|*.ii) in_cc_spec="$in_cc_spec $arg";;
      *.C|*.cxx|*.c++|*.cc|*.cp|*.cpp) in_pp_spec="$in_pp_spec $arg";;
      *.S|*.c) in_pp_spec="$in_pp_spec $arg";;
      *.s) in_as_spec="$in_as_spec $arg";;
      *.o|*.a|-l*) in_ld_spec="$in_ld_spec $arg";;
# SLC file types
      *.iu)  in_cc_spec="$in_cc_spec $arg";;
      *.utc) in_pp_spec="$in_pp_spec $arg";;
      *.sl)  in_slt_spec="$in_slt_spec $arg";;
      *.s0)  in_filt_spec="$in_filt_spec $arg";;

      -L*|-Wl,*)     extra_ldflags="$extra_ldflags $arg" ;;
      -D*|-U*)       extra_ppflags="$extra_ppflags $arg" ;;
      -I*)           extra_inc="$extra_inc $arg" ;;
      -Wa,*)         extra_asflags="$extra_asflags $arg" ;;

      -x)       die "-x not supported yet" ;;

      -mutc*)   die "-mutc is deprecated, used -b instead" ;;

      -*)	extra_cflags="$extra_cflags $arg";;

      *)  die "$arg: unrecognized argument" ;;
  esac
done

# Special actions that do not require processing
if test "x$slc_mode" = xdisplay_version; then
   rev='$Rev$'
   rev=$(echo "$rev"|cut -d' ' -f2)
   cat <<EOF
$basename $version.$rev

This script is copyright (C) 2008 the CSA group - Universiteit van
Amsterdam.

Script front-end written by Raphael Poss. muTC implementations
provided by Thomas Bernard, Mike Lankamp, Simon Polstra, Michiel
W. van Tol and others. GNU C and C++ compilers courtesy of the Free
Software Foundation, Inc.
EOF
   exit 0
elif test "x$slc_mode" = xdisplay_help; then
   cat <<EOF
Usage: $0 [ARG]...

Compile SVP programs.

Execution modes:
  -check             Check the environment; do not process anything. In
                     this mode $basename checks that the required tools
                     are available.

  -EE                Stop after the transformation stage; do not preprocess.
                     The output is in the form of transformed source code,
                     which is sent to the standard output.

  -E                 Stop after the preprocessing stage; do not compile.
                     The output is in the form of preprocessed source code,
                     which is sent to the standard output.

  -S0                Stop after the first stage of compilation proper; do not
                     perform post-compilation filtering on assembly. 
                     The output is in the form of an unprocessed assembler code
                     file for each non-assembler input file specified.

  -S                 Stop after the second stage of compilation proper;
                     do not assemble. The output is in the form of an assembler
                     code file for each non-assembler input file specified.

  -c                 Compile or assemble the source files, but do not link.
                     The linking stage is not done. The output is in the
                     form of an object file for each source file.

SVP implementation selection:
  -b spec            Generate code for the SVP implementation specified by
                     "spec". "spec" is passed through "cce" for validation
                     and alias expansion. See "cce --help" for details.

General options:
  -Idir              Add the directory "dir" to the list of directories
                     to be searched for header files. This applies
                     both to the initial transformation by m4 and to the
                     underlying compiler.

  -P                 Inhibit generation of linemarkers in the output
                     from both the initial transformation by m4 and the C
                     preprocessor.

  -o file            Place output in "file". This applies regardless to
                     whatever sort of output is being produced.

Compiler debugging options:
  -v                 Print (on standard error output) the commands executed
                     to run the stages of compilation. Also print the
                     settings and version number of the tools involved.

  -ftrace-m4=file    Dump the m4 macro expansion trace to file "file".

  -save-temps        Keep intermediate files. If this option is not set,
                     intermediate files generated during compilation are
                     deleted before the program terminates.

Other options:
  -h, --help         Print this help; do not process anything.

  --version          Print $basename's version number; do not process 
                     anything.

All other options are passed transparently to the underlying C/C++
compiler; in particular, the following options may prove useful:

  -Wa,option         Pass "option" as an option to the assembler.

  -Wl,option         Pass "option" as an option to the linker.

  -llibrary          Search the library named "library" when linking.

Environment variables:
  M4                 M4 preprocessor to use. Default is "m4".

  KEEP               If set and not empty, implies option -save-temps.

Examples:

  $basename test.sl

  $basename -o test test1.sl test2.sl

  $basename -EE test.sl

  $basename -S -o test.s test.sl

  $basename -o test test.sl ccode.c

Report bugs and suggestions to the CSA Trac issue tracker, 
or to <r.c.poss@uva.nl>.
EOF
   exit 0
fi

# Here check the configuration
eval $("$root"/cce -s "$impl")

# If we were requested to test the configuration, do it now
if test -n "$check"; then
    if ! test -d $slc_trans; then
	echo "$slc_trans: does not exist or is not a directory" >&2
	exit 1
    else echo "Found translator: $slc_trans"; fi
    if ! $slc_compiler --version >/dev/null 2>&1; then
	echo "$slc_compiler: cannot run" >&2
	exit 1
    else echo "Found compiler: $slc_compiler"; fi
    if ! $slc_aslink --version >/dev/null 2>&1; then
	echo "$slc_aslink: cannot run" >&2
	exit 1
    else echo "Found assembler/linker compiler: $slc_aslink"; fi
    
    echo "Good." >&2
fi


###################################
# Command line additions
###################################
# Include directories
includes="-I$slc_trans -I$incdir"

slc_ppflags="$slc_ppflags $includes $extra_inc"
slc_tflags="$slc_tflags $includes $extra_inc"
case $slc_complang in
    cpp) 
	slc_cflags="$slc_cflags $CXXFLAGS" 
	slc_ppflags="$slc_ppflags $CXXPPFLAGS"
	;;
    c)  
	slc_cflags="$slc_cflags $CFLAGS"
	slc_ppflags="$slc_ppflags $CPPFLAGS"
	;;
    utc) 
	slc_cflags="$slc_cflags $UTCFLAGS"
	slc_ppflags="$slc_ppflags $UTCPPFLAGS"
	;;
esac
slc_ppflags="$slc_ppflags -DSVP_ARCH=$slc_arch -DSVP_DIALECT=$slc_dialect -DSVP_OS=$slc_os $extra_ppflags"
slc_cflags="$slc_cflags $extra_cflags"
slc_asflags="$slc_asflags $slc_cflags $ASFLAGS $extra_asflags"
slc_ldflags="$slc_ldflags $slc_cflags $LDFLAGS $extra_ldflags"


###################################
# Settings special for M4
###################################

# m4 -P: prefix M4 builtins with m4_
# -E: stop after errors
m4flags="-E -P"

if test -n "$synclines"; then
  m4flags="$m4flags -s"
else
  # cpp -P: do not generate synclines
  slc_ppflags="$slc_ppflags -P"
fi

if test -n "$m4trace"; then
  m4flags="$m4flags -dV -o $m4trace"
fi

m4flags="$m4flags $slc_tflags"

###################################
# Construction of compilation chain
###################################

# Select file extension for intermediate source files
case $slc_complang in
    c)
	cc_ext=i
	pp_ext=c
	;;
    cpp)
	cc_ext=ii
	pp_ext=cc
	;;
    utc)
	cc_ext=iu
	pp_ext=utc
	;;
    *)
	die "unrecognized mode $mode" ;;
esac

# Create temporary directory if necessary
if test -n "$tmpdir"; then
    if ! test -d "$tmpdir" -a -w "$tmpdir"; then
	die "$tmpdir: cannot write to directory"
    fi
else
    tmpdir=$(mktemp -d -t slc)
    tempdirs=$tmpdir
fi

# Decide what phases to do and where to stop
defout=-
case $slc_mode in 
    trans) finalstage=T;;
    pp) finalstage=P;;
    cc) finalstage=C;;
    filt) finalstage=F;;
    as) finalstage=A;;
    ld) finalstage=L; defout=a.out;;
esac
combine="$finalstage$combine"
finalname=${outfile:-$defout}

prepare_chain() {
    local inputs addext stage indvar specfiles phrase
    local f first f final target some
    
    inputs=$1
    addext=$2
    stage=$3
    indvar=$4
    specfiles=$5
    phrase=$6
    
    target=
    if test "x$skip" = "x"; then
	if ! expr "$combine" : ".*$stage" >/dev/null; then
	    for f in $inputs; do
		fn=${f##*/}; fn=${fn%*.*}

		case $f in
		    *.S) 
			target=$tmpdir/$fn.s
			in_as_ind="$in_as_ind $target"
			;;
		    *)
			target=$tmpdir/$fn.$addext
			eval "$indvar=\$$indvar' $target'"
		esac
		transforms="R:$target $transforms $stage:$target:$f"
	    done
	else
	    transform=
	    first=
	    for f in $inputs; do
		if test -z "$first"; then first=$f; fi
		transform="$transform:$f"
	    done
	    if test -n "$transform"; then 
		fn=${first##*/}; fn=${fn%*.*}
#		fn=$(basename "$first"|sed -e 's/^\(.*\)\.[^.]*$/\1/g')
		targetbase=$fn.$addext
		if test "x$finalstage" = "x$stage"; then
		    if test "x$finalname" = "x-"; then
			target=$targetbase
		    else
			target=$finalname
		    fi
		else
		    target=$tmpdir/$targetbase
		    transforms="R:$target $transforms"
		fi
		transforms="$transforms $stage:$target$transform"
	    fi
	    if test "x$finalstage" = "x$stage"; then skip=1; fi
	    eval "$indvar=\$$indvar' $target'"
	fi
    else
	for f in $specfiles; do
	    echo "$0: $f: $phrase input file unused because $phrase not run" >&2
	done
    fi
}


# Item lists:
# *_spec: specified on command lne
# *_ind: derivatives

skip=
prepare_chain "$in_slt_spec" $pp_ext T in_pp_ind "$in_slt_spec" "transformation"
prepare_chain "$in_pp_ind $in_pp_spec" $cc_ext P in_cc_ind "$in_pp_spec" "preprocessor"
prepare_chain "$in_cc_ind $in_cc_spec" s0 C in_filt_ind "$in_cc_spec" "compiler"
prepare_chain "$in_filt_ind $in_filt_spec" s F in_as_ind "$in_filt_spec" "post-filter"
prepare_chain "$in_as_ind $in_as_spec" o A in_ld_ind "$in_as_spec" "assembler"
prepare_chain "$in_ld_ind $in_ld_spec" x L unused "$in_ld_spec" "linker"

##############################################
# Start processing

# Print configuration if requested
if test -n "$verbose"; then
  echo "---- $basename: options and settings ----" >&2
  for i in root keep impl \
           M4 m4flags \
           combine outfile tmpdir; do
    eval "echo '  ' $i '->' \$$i" >&2
  done
  set | grep '^slc_'
  echo "---- $basename: build plan -----" >&2
  for i in $transforms; do echo $i >&2; done
  echo "---- $basename: processing... ----" >&2
fi

for t in $transforms; do
  IFS=':' read action target indeps <<EOF 
$t
EOF
  indeps=${indeps/:/ }
  deps=
  for d in $indeps; do
      case $d in
	  *.iu) deps="$deps -x cpp-output $d -x none";;
	  *) deps="$deps $d" ;;
      esac
  done
  capturestdout=
  case $action in
      R) tempfiles="$tempfiles $target"; continue ;;
      T) 
	  res=2
	  cmd="$M4 $m4flags $incdir/proto.m4 $deps"
	  if ! test "$slc_mode" = "trans" -a -z "$outfile"; then capturestdout=1; fi
	  ;;
      P)
	  res=3
	  cmd="$slc_compiler -E $deps $slc_ppflags"
	  if ! test "$slc_mode" = "pp" -a -z "$outfile"; then capturestdout=1; fi
	  ;;
      C)
	  res=4
	  cmd="$slc_compiler -o $target -combine -S $deps $slc_cflags"
	  ;;
      F)
	  res=5
	  if test "x$slc_filter" = "xcp"; then
	      cmd="cat $deps"
	      capturestdout=1
	  else
	      cmd="$slc_filter $target $deps"
	  fi
	  ;;
      A)
	  res=6
	  cmd="$slc_aslink -c -o $target $deps $slc_asflags"
	  ;;
      L)
	  res=7
	  cmd="$slc_aslink -o $target $deps $slc_ldflags"
	  ;;
  esac

  inflight=$target
  export SLC_PHASE=$action
  if test -n "$capturestdout"; then
      if test -n "$verbose"; then echo "$action: $cmd >$target" >&2; fi
      set +e
      $cmd >"$target"
      cmdcode=$?
      set -e
  else
      if test -n "$verbose"; then echo "$action: $cmd" >&2; fi
      set +e
      $cmd
      cmdcode=$?
      set -e
  fi
  inflight=
  if test -n "$verbose"; then echo "=> $cmdcode" >&2; fi
  if test $cmdcode -gt 126; then
      if test -n "$verbose"; then echo "signal or command not found: exit $cmdcode" >&2; fi
      exit $cmdcode
  elif test $cmdcode -gt 0; then
      if test -n "$verbose"; then echo "$action failed: exit $res" >&2; fi
      exit $res
  fi
done

test -n "$verbose" && echo "---- $basename: done. ----" >&2
exit 0


