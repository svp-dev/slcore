#! @BASH@
# $Id$
#
copyright="Copyright (C) 2009 the CSA group - The SL project.."
#
# This program is free software: you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by   
# the Free Software Foundation; either version 2, or (at your option)    
# any later version.  
#   
# This program is distributed in the hope that it will be useful,   
# but WITHOUT ANY WARRANTY; without even the implied warranty of    
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     
# GNU General Public License for more details.    
#   
# You should have received a copy of the GNU General Public License 
# along with this program; if not, write to the Free Software 
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA     
# 02110-1301, USA.    
set -e
basename=$(basename "$0")
root=$(cd $(dirname "$0"); pwd)

# Interface version number
version=2

slc=${SLC:-$root/slc}
runner=${SGR:-$root/sgr}
timeout=$root/timeout

die() {
  echo "$0:" $@ >&2
  exit 2
}

usage() {
 cat <<EOF
SL Unit test and portability checker.

\`$basename' is a generic tester script for SL programs. It tries to
compile and execute the program given as input on multiple SVP
implementations, comparing results.

A test is considered to succeed when the following conditions are met:

- the program compiles and links successfully on all specified SVP
implementations, or it fails to compile on all implementations and
it is marked as not compilable (see below);

- the program runs successfully on all specified SVP implementations,
or the program fails to run on all implementations and it is marked
as not runnable (see below);

- on all runs but the first, the console output of the program is
identical to the output on the first run.

Usage: $0 [SOURCE] [IMPLEMENTATION]...

Options:

  -h, --help    Print this help.
  -v, --version Print a version number.


Multiple implementations can be specified, and each multiple
times. Implementations names are filtered through the \`cce' utility.

Example implementation aliases:

  seqc          sequential C scheduling

  ptl           muTC-ptl (pthreads / C++)

  ppp           "alternate" compiler for MT-Alpha

  utc0          Alpha-gcc compiler

  utcx          "desired muTC" (transform/preprocess only)

If no implementation is specified, or is set to "all", then the
implementations list above are tested, in that order.

The program performs the tests and display results as they become
available using the following format:

SOURCE     XXYZ XXYZ XXYZ ...

The first column contains the name of the SOURCE specified on the
command line. Each subsequent column contains a string of tests
results for the corresponding implementation specifier on the command
line.

Each string of test results has 3 positions:

1. compilation results; one of:

   L   An executable was produced successfully.

  8    A timeout occurred during compilation.

  !    A signal occurred during compilation.

  ?    Compilation succeeded, but a failure was expected.
 
  XT   Translation failed.

  XP   Preprocessing failed.

  XC   Compilation failed.

  XF   Post-compilation failed.

  XA   Assembly failed.

  XL   Linking failed.

  /T   Translation failed, as expected.

  /P   Preprocessing failed, as expected.

  /C   Compilation failed, as expected.

  /F   Post-compilation failed, as expected.

  /A   Assembly failed, as expected.

  /L   Linking failed, as expected.

2) execution results; one of:

  R    Execution succeded without errors.

  8    A timeout occurred.

  !    A signal occurred.

  ?    Execution succeeded, but a failure was expected.

  o    A timeout occurred, as expected.

  .    A signal occurred, as expected.

  -    The program was not run.

3) check of reference output; one of:

  =   The output will be reused as reference.

  D   The output is identical to the reference.

  X   The output is different from the reference.

  -   The output was not checked.

To indicate expected failures, the source code can be annotated as
follows:

  XFAIL: letters...     Indicate that an error or signal is expected
                        at the phase(s) mentioned in "letters".

  XTIMEOUT              Indicate that a timeout is expected 
                        at runtime.

The annotation can appear anywhere; for example in source comments.

For program output comparison, the test assumes that the first
implementation tested produces the reference output; subsequent
implementations are checked against the results of the first run.

During testing a number of intermediate files are generated. If the
SOURCE file is named test.sl, the following files are generated:

  IMPL/test.log         Test log

  IMPL/test.{c,cc,utc}  Source code after transformation

  IMPL/test.{i,ii,ui}   Source code after preprocessing

  IMPL/test.s0          Raw assembly output

  IMPL/test.s           Assembly output

  IMPL/test.o           Object file

  IMPL/test.x           Executable

  IMPL/test.out         Output during execution

If a test is successful the corresponding files are erased after the
test completes, unless the environment variable KEEP is set and
non-empty.

Environment variables:
  SLC            Location of the SL compiler. Default is 
                 "slc" in the same directory as \`$basename'.

  SGR            Location of the SVP generic runner. Default is 
                 "sgr" in the same directory as \`$basename'.

  KEEP           If set, do not erase intermediary files when a test
                 succeeds. Default is not set.

  TEST_HERE      If set and not empty, use a subdirectory in the current
                 directory for each implementation instead of a
                 subdirectory in the program's source directory.

  TEXT_ONLY      If set and not empty, use plain text messages instead
                 of colored/positioned characters on the console.

Diagnostics:
  0              The test succeeded.

  1              The test failed.

  2              Invalid test parameters.

Report bugs and suggestions to the CSA issue tracker.
EOF
   exit 0 
}


if test "$1" = "--help" -o "$1" = "-h"; then
  usage
  exit 0
elif test "$1" = "--version" -o "$1" = "-v"; then
  rev='$Rev$'
  rev=$(echo "$rev"|cut -d' ' -f2)
  cat <<EOF
$basename $version.$rev

$copyright
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

Written by Raphael 'kena' Poss.
EOF
  exit 0
fi

# Sanity check: verify that dependencies are there.
test_exec() {
  if ! test -x "$1"; then
     die "$1: not found or not executable"
  fi
}
test_exec "$slc"
test_exec "$runner"
test_exec "$timeout"

# Compute base name and directory of test source.
testdir=$(dirname "$1")
testsrc=$1

case $1 in
  *.sl)     testname=$(basename "$1" .sl);;
  *.s)      testname=$(basename "$1" .s);;
  *)
  cat <<EOF
Usage: $basename [SOURCE] [IMPLEMENTATION]...
   or: $basename -h
EOF
   exit 2
esac

shift

case $1 in
  ""|all)
    impl1=seqc
    set ptl ppp 'ppp:SIMARGS=-o NumProcessors=1' utcx
    ;;
  *)
    impl1=$1
    shift
    ;;
esac

if test ! -r $testsrc; then
   die "$testsrc: cannot read file" 
fi

check_status() {
    status=ok
    if test $1 = 127; then status=invcmd
    elif test $1 = 0; then status=ok
    elif test $1 -lt 127; then status=error; errcode=$1
    elif test $1 = 137; then status=timeout
    else status=signal; signal=$(expr $1 - 128)
    fi
    if test $status = signal; then echo "Terminated with signal $signal" >&2; fi
    if test $status = error; then echo "Terminated with status code $errcode" >&2; fi

    # Bailout if invalid command or command was interrupted (SIGINT = 2).
    if test $status = invcmd || test $status = signal -a "$signal" = 2; then exit $1; fi
}

place_chars() {
  local offset color chars str nicemsg
  offset=$1
  color=$2
  chars=$3
  if test -n "$TEXT_ONLY"; then
      case $color in
	  32) nicemsg=good ;;
	  33) nicemsg=xfail ;;
	  31) nicemsg=bad ;;
	  37) nicemsg=skip ;;
	  *) nicemsg="???" ;;
      esac
      echo "$testsrc: $outdir: $impl1: $chars ($nicemsg)"
  else
      str=$(printf '\r\033[%sC\033[%sm%s\e[0m' $offset $color "$chars")
      printf "%s" "$str"
  fi
}

report_compile() {
  local code offset color char str outlog
  code=$1
  offset=$2
  outlog=$3
  check_status "$code" 2>>"$outlog"
  fail=0
  dorun=1
  case $status in
    signal)  color=31; char="! "; fail=1 ;;
    timeout) color=31; char="8 "; fail=1 ;; 
    ok)      if grep -q "XFAIL:.*[TPCFAL]" "$testsrc"; then color=31; char="? "; fail=1; else color=32; char=" L"; fi ;;
    error) 
       case $errcode in
          1) color=31; char="X "; fail=1 ;;
          2) if grep -q "XFAIL:.*T" "$testsrc"; then color=33; char="/T"; else color=31; char="XT"; fail=1; fi;;
          3) if grep -q "XFAIL:.*P" "$testsrc"; then color=33; char="/P"; else color=31; char="XP"; fail=1; fi;;
          4) if grep -q "XFAIL:.*C" "$testsrc"; then color=33; char="/C"; else color=31; char="XC"; fail=1; fi;;
          5) if grep -q "XFAIL:.*F" "$testsrc"; then color=33; char="/F"; else color=31; char="XF"; fail=1; fi;;
          6) if grep -q "XFAIL:.*A" "$testsrc"; then color=33; char="/A"; else color=31; char="XA"; fail=1; fi;;
          7) if grep -q "XFAIL:.*L" "$testsrc"; then color=33; char="/L"; else color=31; char="XL"; fail=1; fi;;
          *) color=31; char="??"; fail=1 ;;
       esac
       dorun=0
  esac
  if expr "$impl" : '.*x' >/dev/null; then
     if test $status = error -a $errcode -ge 3 -a $errcode -le 7; then
        color=33; char=" |"; fail=0; dorun=0
     fi
  fi
  if test $fail = 1; then
    dorun=0
  fi
  place_chars $offset $color "$char"
}

report_run() {
  local code offset outlog color char str
  code=$1
  offset=$2
  outlog=$3
  check_status "$code" 2>>"$outlog"
  fail=0
  dodiff=1
  case $status in
    signal)  dodiff=0; 
             if grep -q "XFAIL:.*R" "$testsrc"; then color=33; char="."; else color=31; char="!"; fail=1; fi;;
    timeout) dodiff=0; 
             if grep -q "XTIMEOUT" "$testsrc"; then color=33; char="o"; else color=31; char="8"; fail=1; fi;;
    ok)      if grep -q "XFAIL:.*R" "$testsrc"; then color=31; char="?"; fail=1; else color=32; char="R"; fi ;;
    error)   dodiff=0;
             if grep -q "XFAIL:.*R" "$testsrc"; then color=33; char="/"; else color=31; char="X"; fail=1; fi;;
  esac
  place_chars $offset $color "$char"
}

do_compile() {
  local offset command x
  offset=$1
  echo "===== TEST: $testsrc, COMPILE ======" >$baseout.log
  command="$timeout $slc -v -t $outdir -b $impl -o $baseout.x $testsrc"
  echo "$command" >>$baseout.log
  set +e
  KEEP=1 TIMEOUT=40 $command >>$baseout.log 2>&1
  x=$?
  set -e

  report_compile $x $offset $baseout.log
}

do_run() {
  local offset command x
  offset=$1

  dodiff=1
  if test $dorun = 0; then
    echo "Not running program since no executable was produced." >>$baseout.log
    place_chars $offset 37 "-"
    dodiff=0
  else
      echo "===== RUNNING PROGRAM =====" >>$baseout.log
      command="$timeout $runner $baseout.x"
      echo "$command >$baseout.out" >>$baseout.log
      set +e
      $command >$baseout.out 2>>$baseout.log 
      x=$?
      set -e

      report_run $x $offset $baseout.log
  fi
}

do_diff() {
  local offset refout str
  offset=$1
  refout=$2

  if test $fail = 1 -o $dorun = 0 -o $dodiff = 0; then
    echo "Not testing output." >>$baseout.log
    place_chars $offset 37 "-"
  else
      echo "===== CHECKING OUTPUT =====" >>$baseout.log
      echo "diff -u $refout $baseout.out" >>$baseout.log
      if diff -u "$refout" "$baseout.out" >>"$baseout.log" 2>&1; then
	  echo "Output identical to reference" >>$baseout.log
	  place_chars $offset 32 D
      else
	  place_chars $offset 31 X
	  fail=1
      fi
  fi
}



do_check() {
  local offset refout compref b
  impl=$1
  offset=$2
  refout=$3

  do_compile $offset
  offset=$(expr $offset + 2)
  do_run $offset
  offset=$(expr $offset + 1)
  if test -n "$refout"; then
      do_diff $offset "$refout"
  else
      if test $dodiff = 0; then
	  place_chars $offset 37 "-"
      else
	  place_chars $offset 32 "="
      fi
  fi
  if test $fail = 0 -a -z "$KEEP"; then
    if test "x$refout" = "x"; then
      compref=$baseout.out
    else
      compref=$refout
    fi
    for b in "$baseout"*; do
       if test "x$compref" != "x$b"; then
          rm "$b"
       fi
    done
    rmdir "$outdir" >/dev/null 2>&1 || true
  fi
  return $fail
}

do_preptest() {
    local vars save vn var val
    impl=$(echo "$1" | cut -d: -f1)
    vars=$(echo "$1" | cut -d: -f2-)
    if test -n "$vars"; then
	save=$IFS
	IFS=":"
	for vn in $vars; do
	    var=$(echo "$vn"|cut -d= -f1)
	    val=$(echo "$vn"|cut -d= -f2-|sed -e s/\'/\'\"\'\"\'/g)
	    eval "export $var='$val'"
	done
	IFS=$save
    fi
    
    outdir=$testdir/_$counter
    counter=$(expr $counter + 1)
    if test -n "$TEST_HERE"; then
	outdir=$(echo "_$outdir"|tr '/.:' '___')
    fi
    baseout=$outdir/$testname
    
    if ! mkdir -p "$outdir" >/dev/null 2>&1; then
	die "$outdir: cannot create directory" 
    fi
    
    if ! test -w "$outdir"; then
	die "$outdir: directory is not writable"
    fi
    rm -f "$baseout"*
}


if test -z "$TEXT_ONLY"; then
    # find terminal width and squeeze first
    # column as needed
    if stty size >/dev/null 2>&1; then
	COLUMNS=$(stty size|cut -d' ' -f2)
    fi
    COLUMNS=${COLUMNS:-80}
    nrimpl=$#
    nrcols=$(expr \( $nrimpl + 1 \) \* 5)
    remainder=$(expr $COLUMNS - $nrcols - 5)
    if test $remainder -lt 20; then remainder=20; fi
    name=$testsrc
    namelen=$(echo "$name"|wc -c)
    if test $namelen -gt $remainder; then
	name=$(echo "$name"|sed -e 's,\([0-9]_\)[^/]*,\1*,g')
	namelen=$(echo "$name"|wc -c)
	rem=$(expr $remainder - 3)
	if test $namelen -gt $rem; then
	    name=$(echo "$name"|sed -e 's/^.*\(.\{'$rem'\}\)$/...\1/g')
	fi
    fi
    printf "%-${remainder}s" "$name"
fi

# start testing
counter=0
do_preptest "$impl1"

bye() {
  local sig
  sig=$1
  for pid in $towait; do
    kill $pid >/dev/null 2>&1
  done
  signalled=$sig
}

check_proc() {
    local x
    x=$1
    if test -n "$signalled"; then 
	echo "Signal received (SIG$signalled)!" >&2
	trap - INT QUIT HUP TERM PIPE
        kill -$signalled $$
	exit 128
    elif test $x != 0; then
	fail=1
    fi
}

offset=${remainder:-0}
fail=0
# Start with first impl, need to wait for it
# since output will be used as reference:

signalled=
trap "bye INT" INT
trap "bye QUIT" QUIT
trap "bye HUP" HUP
trap "bye TERM" TERM
trap "bye PIPE" PIPE
do_check $impl $offset &
towait=$!
set +e
wait $towait
x=$?
set -e
check_proc $x

# Perform other tests asynchronously
towait=
refout=$baseout.out
for impl1 in "$@"; do
    offset=$(expr $offset + 5)
    do_preptest "$impl1"
    do_check $impl $offset "$refout" &
    towait="$towait $!"
done

# After they are started, wait on them
for w in $towait; do
    set +e
    wait $w
    x=$?
    set -e
    check_proc $x
done

if test -z "$TEXT_ONLY"; then
    offset=$(expr $offset + 5)
    if test $fail = 0; then
	place_chars $offset 37 "\o/"
    else
	place_chars $offset 31 ":("
    fi
    echo
else
    if test $fail = 0; then
	echo "$testsrc: test(s) succeeded."
    else
	echo "$testsrc: test(s) failed."
    fi
fi

if test $fail = 0 -a -z "$KEEP"; then
    rm "$refout"
    rmdir $(dirname "$refout") >/dev/null 2>&1 || true
fi
exit $fail

# -*- mode: shell -*-
